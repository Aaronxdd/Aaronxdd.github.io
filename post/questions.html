<!DOCTYPE html><html lang="en-US"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try {var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem('theme');if("system"===e||(!e&&true)){var t="(prefers-color-scheme: dark)",m=window.matchMedia(t);m.media!==t||m.matches?d.add('dark'):d.add('light')}else if(e) d.add(e)}catch(e){}}()</script><title>面试题集合（真题篇） | Xu dongdong&#x27;s blog</title><meta name="description" content="A blog created with Next.js and Tailwind.css"/><meta property="og:type" content="website"/><meta name="og:title" property="og:title" content="面试题集合（真题篇）"/><meta name="og:description" property="og:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="面试题集合（真题篇）"/><meta name="twitter:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:creator" content="https://twitter.com/WhyYouJames"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/f8d73a71d7937abe53e1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8d73a71d7937abe53e1.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-c6f966696d7d46f48c33.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" as="script"/><link rel="preload" href="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.102498c830e6881bc94f.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bslug%5D-13092b6d8cea2defd1b4.js" as="script"/></head><body><div id="__next"><div class="w-full min-h-screen dark:bg-gray-700 dark:text-white flex"><div class="max-w-screen-md px-4 py-12 mx-auto antialiased font-body flex flex-col flex-grow"><header class="flex items-center justify-between  mb-2"><div class="max-w-lg"><h1><a class="text-2xl font-black text-black no-underline font-display dark:text-white" href="/">Xu dongdong&#x27;s blog</a></h1></div></header><main class="flex-grow"><article><header class="mb-8"><h1 class="mb-2 text-6xl font-black leading-none font-display">面试题集合（真题篇）</h1></header><div class="mb-4 prose lg:prose-lg dark:prose-dark"><h2>1. 性能优化 ：项⽬⾥做过哪些性能优化，怎么检测性能，有没有实际测过优化的数据有多少提升</h2><p><picture class="w-full"><source type="image/webp" data-srcset="/_next/static/images/performance-bb4ca0ade37b80e3918e3ef1e247d46a.jpeg.webp"/><source type="image/png" data-srcset="/_next/static/images/performance-b4046ed3b7410b5a65763340b00f71fc.jpeg"/><img class="lazyload blur w-full" alt="性能优化" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAgACgMBEQACEQEDEQH/xAGiAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgsQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+gEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoLEQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AP7l5rzWdQ8PeL4LoZm3+ILG/hg1V0u7CQeeukwWFtcveRTWuoQSxzyGaXR5UgkEVvaXTLHDH6MYUY+yd2n7so81PmhJae0cqnuOMoKzioxrRv8AFKndt8Up1Hzq2mqklO01/JywfMpKWqk5SpO1rKeiXplrdXL21uzR2YZoIWYPfBXDGNSQwiszEGBPzCMmMHIQ7cVwNRTau930/wCCdacrLRbLr5eh/9k="/></picture></p><h3>性能优化</h3><ul><li><p>避免过多的回流与重绘</p><p>实质上是避免过多的 <strong>render tree</strong> 操作，避免使用table布局；DOM结构避免嵌套过深</p></li><li><p>JavaScript、Css、Html压缩</p></li><li><p>splitChunks 拆包</p></li><li><p>网页中可视化部分（图片，视频等）采用骨架</p></li><li><p>函数的频繁调用考虑使用防抖节流</p></li><li><p>多利用缓存（多跟服务器端有关）</p></li><li><p>大的基础库使用CDN</p></li><li><p>用上懒加载和预加载</p></li><li><p>使用Service Worker</p></li></ul><h3>检测性能</h3><ul><li>很直观的看network页面的load时间</li><li>lighthouse进行检测</li><li>用webpack-bundle-analyzer查看打包后资源情况</li></ul><h2>2. http2.0有哪些特性？https是怎么加密的，https强缓存在项目中怎么用的</h2><h3>http2.0的特性</h3><ul><li><p>二进制分帧</p><p>HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率</p></li><li><p>多路复用</p><p>一次链接成功后，只要链接还没断开，那么 client 端就可以在一个链接中<strong>并发</strong>地发起多个请求，每个请求及该请求的响应不需要等待其他的请求，某个请求任务耗时严重，不会影响到其它连接的正常执行</p></li><li><p>头部压缩</p><p>由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源</p></li></ul><h3>HTTP 与 HTTPS</h3><ul><li>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</li><li>HTTP 的端口号是 80，HTTPS 是 443</li><li>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费</li><li>HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><h3>浏览器缓存策略</h3><h2>3. web安全（xss/csrf）</h2><h3>xss（Cross-Site Scripting）</h3><p><strong>定义</strong></p><p>跨站脚本攻击，简称脚本注入</p><p><strong>原理</strong></p><p>恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p><p><strong>防范</strong></p><ul><li>HttpOnly 防止劫取 Cookie，浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。</li><li>输入检查，对 <strong>&lt;</strong>  、 <strong>&gt;</strong> 进行转译，使得恶意的脚本内容无法执行（React DOM 会在渲染的时候把内容（字符串）进行转义）</li></ul><h3>csrf</h3><p><strong>定义</strong></p><p>跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式</p><p><strong>原理</strong></p><p>利用同域下cookie可以共享，在A页面中嵌入B页面的请求，如果用户登录过B页面，即在A中的B请求可以获取B服务器信任。</p><p><strong>防范</strong></p><ul><li>Token验证</li></ul></div><hr class="mt-4"/><footer><div class="flex items-center mt-8 mb-16"><picture class="flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow"><source type="image/webp" data-srcset="/_next/static/images/profile-8ed88833980dc158e6d9ec3b1bb7c0a8.png.webp"/><source type="image/png" data-srcset="/_next/static/images/profile-44443f720aaa2ff4c2b67336ff9f586b.png"/><img class="lazyload blur flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow" alt="Profile" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAAFBSURBVAXBSS8DYQCA4fcz33RqWpUuU8tEkKjtUqIhJELiRCJxcfRf/AknP8OFiwMXF40DSVO0iRhLVbR0mX08jzg63Ikc28NzA1QR8vBcJ6Eq9AYUDMNAxlOsrBSRH40WIoLJbIL1qTzS63JvfRKJECd0MM0h9IREmZ4YOyaAw7UCG6UlNpfneaw8UbNa4Ie4tk9uSEO6nouCoO9FZEZNWu8WcUViZpLsH+wyMjnBX7eDzCuQ0zVsAtpvb1RrL9Stb3RNkO//MSwl6mAcWRrNMLO1jZ5UuSiXITXO6vISp+eXbNs+olal02kj/YUidiyJ5wsK63u8N74xSxmmyrecnF2TNtJoUkUa2RxO95ew3+al1yXm9tCCiLnCLPqrRbP5QSRC5GLsi0DVkekUj5UKjZ8+TSdA6ikWigYDqs/VzR3/TEV/Airrby8AAAAASUVORK5CYII="/></picture><p class="text-base leading-7">Written by <b class="font-semibold">xudd</b> <!-- -->who wants to become rich！！！<!-- --> <a href="https://twitter.com/https://twitter.com/WhyYouJames">Follow him on twitter</a></p></div></footer></article><nav class="flex flex-wrap justify-between mb-10"><a class="text-lg font-bold" href="/post/write">← <!-- -->面试题集合（手撕代码篇）</a><a class="text-lg font-bold" href="/post/js">面试题集合（JS篇）<!-- --> →</a></nav></main><footer class="text-lg font-light mt-3">© <!-- -->2021<!-- --> <!-- -->Built with<!-- --> <a href="https://nextjs.org/">Next.js</a>🔥, Deployed on<!-- --> <a href="https://pages.github.com/">GitHub Pages</a></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"面试题集合（真题篇）","date":"July 5, 2021","description":null},"post":{"content":"\n## 1. 性能优化 ：项⽬⾥做过哪些性能优化，怎么检测性能，有没有实际测过优化的数据有多少提升\n  ![性能优化](performance.jpeg)\n\n### 性能优化\n\n- 避免过多的回流与重绘\n  \n  实质上是避免过多的 **render tree** 操作，避免使用table布局；DOM结构避免嵌套过深\n\n- JavaScript、Css、Html压缩\n- splitChunks 拆包\n- 网页中可视化部分（图片，视频等）采用骨架\n- 函数的频繁调用考虑使用防抖节流\n- 多利用缓存（多跟服务器端有关）\n- 大的基础库使用CDN\n- 用上懒加载和预加载\n- 使用Service Worker\n  \n### 检测性能\n\n- 很直观的看network页面的load时间\n- lighthouse进行检测\n- 用webpack-bundle-analyzer查看打包后资源情况\n  \n## 2. http2.0有哪些特性？https是怎么加密的，https强缓存在项目中怎么用的\n\n### http2.0的特性\n- 二进制分帧\n\n  HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率\n\n- 多路复用\n  \n  一次链接成功后，只要链接还没断开，那么 client 端就可以在一个链接中**并发**地发起多个请求，每个请求及该请求的响应不需要等待其他的请求，某个请求任务耗时严重，不会影响到其它连接的正常执行\n\n- 头部压缩\n  \n  由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源\n\n### HTTP 与 HTTPS\n\n- HTTP 是明文传输，HTTPS 通过 SSL\\TLS 进行了加密\n- HTTP 的端口号是 80，HTTPS 是 443\n- HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费\n- HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n\n### 浏览器缓存策略\n\n## 3. web安全（xss/csrf）\n\n### xss（Cross-Site Scripting）\n\n**定义**\n\n跨站脚本攻击，简称脚本注入\n\n**原理**\n\n恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。\n\n**防范**\n\n- HttpOnly 防止劫取 Cookie，浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。\n- 输入检查，对 **\u003c**  、 **\u003e** 进行转译，使得恶意的脚本内容无法执行（React DOM 会在渲染的时候把内容（字符串）进行转义）\n\n\n### csrf\n\n**定义**\n\n跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式\n\n**原理**\n\n利用同域下cookie可以共享，在A页面中嵌入B页面的请求，如果用户登录过B页面，即在A中的B请求可以获取B服务器信任。\n\n**防范**\n\n- Token验证\n","excerpt":""},"previousPost":{"slug":"write","frontmatter":{"title":"面试题集合（手撕代码篇）","date":"July 5, 2021","description":null},"excerpt":"","content":"\n  \n## 1. 手写 bind、call、apply\n\n``` javascript\n// call\nFunction.prototype.myCall = (content) =\u003e {\n  content = content || window;\n  content.fn = this;\n  const args = [...arguments].slice(1);\n  const result = content.fn(args);\n  delete content.fn;\n  return result;\n}\n\n// apply\nFunction.prototype.myApply = (content) =\u003e {\n  content = content || window;\n  content.fn = this;\n  let result\n  if (arguments[1] \u0026\u0026 Array.isArray(arguments[1])) {\n    if (arguments[1].length === 1) {\n      result = content.fn(...arguments[1])\n    } else {\n      result = content.fn()\n    }\n  }\n  delete content.fn\n  return result\n}\n\n// bind\nFunction.prototype.myBind = (content) =\u003e {\n  content = content || window;\n  content.fn = this;\n  const args = [...arguments].slice(1);\n  return () =\u003e {\n    content.fn(args)\n  }\n}\n```\n\n## 2. 手写防抖节流\n   \n   防抖\n   ``` javascript\n    const debounce = (fn, delay) =\u003e {\n      let timeout = null;\n      return () =\u003e {\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        timeout = setTimeout(() =\u003e {\n          fn.call(this, arguments)\n        }, delay)\n      }\n    }\n   ```\n   节流\n   ``` javascript\n    const throttle = (fn, delay) =\u003e {\n      let canRun = true;\n      if (!canRun) {\n        return\n      }\n      canRun = false;\n      setTimeout(() =\u003e {\n        fn.call(this. arguments);\n        canRun = true;\n      }, delay);\n    }\n   ```\n\n## 3. 手写数组flat\n\n``` javascript\nconst flat = arr =\u003e {\n  arr.reduce((pre, value) =\u003e {\n    return pre.concat(Array.isArray(value) ? flat(value) : value)\n  }, []);\n}\n```\n\n## 4. 写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal\n\n``` javascript\nfunction mySetInterVal(fn, a, b) {\n  this.a = a;\n  this.b = b;\n  this.time = 0;\n  this.handle = -1;\n  this.start = () =\u003e {\n    this.handle = setTimeout(() =\u003e {\n      fn();\n      this.time++;\n      this.start();\n    }, this.a + this.time * this.b);\n  }\n\n  this.stop = () =\u003e {\n    clearTimeout(this.handle);\n    this.time = 0;\n  }\n}\n\nvar a = new mySetInterVal(() =\u003e {console.log('123')},1000, 2000 );\na.start();\na.stop();\n```\n\n## 5. 斐波那契数列\n   \n``` javascript\nconst Fibonacci = (n) =\u003e {\n  if (n \u003c 0) throw new Error('输入的数字不能小于0');\n  if (n \u003c 2) return n;\n  return Fibonacci(n - 1) + Fibonacci(n - 2)\n}\n```\n   \n## 7. 实现 add(1)(2)(3)\n   \n``` javascript\nconst add = (a) =\u003e (b) =\u003e (c) =\u003e a + b + c;\n```\n\n## 8. 数据类型判断\n\ntypeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。\n\n``` javascript\nconst getType = (obj) =\u003e {\n  return Object.prototype.toString.call(obj).slice(8, -1);\n}\n```\n\n## 9. 数组扁平化\n    \n数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：\n\n``` javascript\n[1, [2, [3]]].flat(2)  // [1, 2, 3]\n```\n\n关键：递归\n\n``` javascript\nconst flatten = arr =\u003e {\n  let newArr = [];\n  for(let i = 0; i \u003c arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      newArr.concat(flatten(arr[i]))\n      return\n    }\n    newArr.push(arr[i])\n  }\n  return neaArr;\n}\n```\n\n## 10. 深浅拷贝\n\n浅拷贝：只考虑对象类型\n\nES5版\n``` javascript\nfunction shallowCopy(obj) {\n  if (typeof obj !== 'object') return\n\n  let newObj = obj instanceof Array ? [] : {};\n\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = obj[i];\n    }\n  }\n\n  return newObj;\n}\n```\n\nES6版\n``` javascript\nconst shallowCopy = obj =\u003e Array.isArray(obj) ? [...obj] : {...obj}\n```\n\n深拷贝\n\n``` javascript\nconst deepClone = obj =\u003e {\n  if (typeof obj !== 'object') return;\n  let newObj = obj instanceof Array ? [] : {};\n  \n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (typeof obj[key] === 'object') {\n        newObj[key] = deepClone(obj[key]);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  return newObj;\n}\n```\n\n## 11. 解析 URL 参数为对象\n  \n``` javascript\nconst urlSearch = href =\u003e {\n  let obj = {};\n  const queryIndex = href.indexOf('?');\n  const urlOptions = href.slice(queryIndex + 1, href.length);\n  const options = urlOptions.split('\u0026');\n  options.map(option =\u003e {\n    const equalIndex = option.indexOf('=');\n    obj[option.slice(0, equalIndex)] = option.slice(equalIndex + 1, option.length);\n  });\n  return obj;\n}\n```\n\n## 12. 实现柯里化（Currying）\n\n``` javascript\nfunction curry(fn) {\n    let judge = (...args) =\u003e {\n        if (args.length == fn.length) return fn(...args)\n        return (...arg) =\u003e judge(...args, ...arg)\n    }\n    return judge\n}\n```\n\n## 13. 手写AJAX\n\n``` js\nconst myAjax = (url) =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.onreadystatechange = () =\u003e {\n      if (xhr.readyState !== 4) return\n      if (xhr.status === 200) {\n        resolve(xhr.responseText)\n      } else {\n        reject(xhr.responseText)\n      }\n    }\n    xhr.send();\n  })\n}\n```\n\n## 14. 手写Promise\n\n``` javascript\nconst PADDING = \"PADDING\";\nconst FULFILLED = \"FULFILLED\";\nconst REJECTED = \"REJECTED\";\n\nclass MyPromise {\n  constructor(executor) {\n    this.status = PADDING;\n    this.value = undefined;\n    this.error = undefined;\n\n    let resolve = (value) =\u003e {\n      if (this.status === PADDING) {\n        this.value = value;\n        this.status = FULFILLED;\n      }\n    }\n\n    let reject = (error) =\u003e {\n      if (this.status === PADDING) {\n        this.error = error;\n        this.status = REJECTED;\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n      onFulfilled(this.value)\n    }\n\n    if (this.status === REJECTED) {\n      onRejected(this.error)\n    }\n  }\n}\n```\n    \n## 15. 实现 Promise.all\n  \n``` js\nconst promiseAll = (promises) =\u003e {\n  if (Array.isArray(promises)) {\n    throw new Error('the arguments must be an array !!!')\n  }\n  const promisesLength = promises.length;\n  let current = 0, result = [];\n  new Promise((resolve, reject) =\u003e {\n    promises.forEach((promise, i) =\u003e {\n      Promise.resolve(promise).then(value =\u003e {\n        current ++;\n        result[i] = value;\n        if (current === promisesLength) {\n          resolve(result)\n        }\n      }, error =\u003e reject(error))\n    })\n  })\n}\n```\n\n## 16. 手写模版字符串\n\n``` javascript\nconst render = (str, data) =\u003e {\n  const reg = /\\{\\{(\\w+)\\}\\}/;\n  if (reg.test(str)) {\n    const key = reg.exec(str)[1];\n    str = str.replace(reg, data[key]);\n    return render(str, data);\n  }\n  return str;\n} \n```"},"nextPost":{"slug":"js","frontmatter":{"title":"面试题集合（JS篇）","date":"July 5, 2021","description":null},"excerpt":"","content":"\n## 1. infinity代表什么数据\n\n  在JS中Infinity用于表示无穷大的数值，且不是常量，即无法明确表示它到底有多大。可以通过isFinite(val)判断当前数字是否是无穷大，函数返回true表示不是无穷大，返回false表示是无穷大。\n\n\n## 2. 如何计算动画的帧率（FPS）\n\n- 可以借助requestAnimationFrame API，requestAnimationFrame 使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。\n\n- requestAnimationFrame的回调函数执行次数通常与浏览器屏幕刷新次数相匹配，而利用这个API实现动画的原理就是回调函数内再次调用requestAnimationFrame，所以页面不断重绘时，然后检测1秒内requestAnimationFrame调用的次数，就是当前的FPS\n\n\n## 3. 请说说new String(\"A\")和String(\"A\")分别返回的结果，请解释为什么\n\n- new String(\"A\") :\n  \n  返回类型：引用类型，堆内存存储\n  返回值：字符串对象\n\n- String(\"A”) ：\n  \n  返回类型：基本类型，栈内存存储\n  返回值：字符串值\n\n## 4. 请通过reduce函数实现一维数组的求和\n\n``` javascript\nconst sum = arr =\u003e arr.reduce((a, b) =\u003e a + b)\n```\n\n## 5. 请说说严格模式下的this指向\n\n- 在严格模式下，在全局作用域中，this指向window对象\n- 在严格模式下，函数中的this等于undefined\n- 在严格模式下，对象的函数中的this指向调用函数的对象实例\n- 在严格模式下，构造函数中的this指向构造函数创建的对象实例。\n- 在严格模式下，在事件处理函数中，this指向触发事件的目标对象。\n\n## 6. 图片懒加载原理\n   \n  图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的\n\n- 拿到所有的图片 dom 。\n- 遍历每个图片判断当前图片是否到了可视区范围内。\n- 如果到了就设置图片的 src 属性。\n- 绑定 window 的 scroll 事件，对其进行事件监听（搭配节流）。\n\n``` js\nlet imgList = [...document.querySelectorAll('img')]\nlet length = imgList.length\n\n// 修正错误，需要加上自执行\n- const imgLazyLoad = function() {\n+ const imgLazyLoad = (function() {\n    let count = 0\n    \n   return function() {\n        let deleteIndexList = []\n        imgList.forEach((img, index) =\u003e {\n            let rect = img.getBoundingClientRect()\n            if (rect.top \u003c window.innerHeight) {\n                img.src = img.dataset.src\n                deleteIndexList.push(index)\n                count++\n                if (count === length) {\n                    document.removeEventListener('scroll', imgLazyLoad)\n                }\n            }\n        })\n        imgList = imgList.filter((img, index) =\u003e !deleteIndexList.includes(index))\n   }\n- }\n+ })()\n\n// 这里最好加上节流处理\ndocument.addEventListener('scroll', imgLazyLoad)\n\n```\n\n## 7. 懒加载和预加载\n\n  两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n## 8. 如何区分返回内容是文件流还是json数据\n\n``` javascript\nawait (await fetch(url)).blob();\n// Blob {size: 100, type: \"application/json\"}\n// Blob {size: 73226, type: \"image/jpeg\"}\n```\n\n## 9. 写一个方法判断js的方法是内置的还是自定义的\n\ntoString一下\n``` javascript\nfunction isNative (f) {\n    return typeof f === 'function' \u0026\u0026 /native code/.test(f.toString())\n}\n```\n\n## 10. 微任务与宏任务\n\n- JavaScript是单线程的语言\n- Event Loop是javascript的执行机制\n\n![interview-js-event-loop](interview-js-event-loop.jpeg)\n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数\n- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n  js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数，也就是说‘同一层’既有微任务也有宏任务的时候，先执行微任务\n\n``` javascript\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n```\n\n## 11. 函数的方法 call()、apply()、bind()的区别\n\n### 改变函数执行上下文，也就是改变this的指向\n\n- call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。\n- call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n\n## 12. 前端性能优化\n- 减少 HTTP 请求\n- 使用 HTTP2\n- 使用服务端渲染\n  \n  客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\n  服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\n\n- 静态资源使用 CDN\n- 将 CSS 放在文件头部，JavaScript 文件放在底部\n- 使用字体图标 iconfont 代替图片图标\n- 善用缓存，不重复加载相同的资源\n- 压缩文件（js，css，图片）\n- 图片优化（懒加载，base64）\n- 分chunk，大的库考虑用CDN（react，router等）\n- 使用事件委托\n- if-else 对比 switch\n  \n  当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\n- 使用 Web Workers\n- 降低 CSS 选择器的复杂性（勿嵌套多层）\n\n## 13. 什么是防抖和节流，应用场景是啥\n    \n### 都是用于限制函数被频繁调用\n\n**防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**\n\n场景：有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。\n\n**节流：任务频繁触发的情况下，指定时间间隔内只会执行一次任务。**\n\n场景：懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取；双十一抢商品\n\n## 14. 实现链式调用\n    \n链式调用的核心就在于调用完的方法将自身实例返回\n\n``` javascript\nfunction Class1() {\n    console.log('初始化')\n}\nClass1.prototype.method = function(param) {\n    console.log(param)\n    return this\n}\nlet cl = new Class1()\n//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。\ncl.method('第一次调用').method('第二次链式调用').method('第三次链式调用')\n```\n    \n## 15. 继承\n    \n**原型链继承**\n\n``` javascript\nfunction Animal() {\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getColor = function() {\n    return this.colors\n}\nfunction Dog() {}\nDog.prototype =  new Animal()\n\nlet dog1 = new Dog()\ndog1.colors.push('brown')\nlet dog2 = new Dog()\nconsole.log(dog2.colors)  // ['black', 'white', 'brown']\n```\n\n**问题**\n\n- 原型中的属性会被共享\n- 实例化时无法给父类构造函数传参\n  \n**借用构造函数实现继承**\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.getName = function() {\n        return this.name\n    }\n}\nfunction Dog(name) {\n    Animal.call(this, name)\n}\n```\n借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以**会导致每次创建子类实例都会创建一遍方法**。\n\n**组合继承**\n\n组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getName = function() {\n    return this.name\n}\nfunction Dog(name, age) {\n    Animal.call(this, name)\n    this.age = age\n}\nDog.prototype =  new Animal()\nDog.prototype.constructor = Dog\n\nlet dog1 = new Dog('奶昔', 2)\ndog1.colors.push('brown')\nlet dog2 = new Dog('哈赤', 1)\nconsole.log(dog2) // { name: \"哈赤\", colors: [\"black\", \"white\"], age: 1 }\n```\n\n## 16. js中的堆栈\n    \n### 栈数据结构\n\n- 栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。\n- 栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。\n\n### 堆数据结构\n\n- 堆是一种经过排序的树形数据结构，每个结点都有一个值。\n- 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。\n\n### 变量类型与内存的关系\n\n#### 基本数据类型\n\nSting、Number、Boolean、null、undefined、Symbol\n\n- 基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。\n- 引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址\n\n\n## 17. Proxy的理解\n\n### 回答要点\n- Proxy的作用（拦截读取，写入等操作，可以覆盖原生操作）\n- Proxy和Object.defineProperty的区别（优势，Vue3用Proxy取代2版的defineProperty）\n- Reflect的用法（了解）\n\n### 链接\n[Proxy 和 Reflect](https://juejin.cn/post/6844904090116292616)\n\n## 18. Generator详解\n\n- 可控制的异步流程\n- async是Generator的实现（语法糖）\n\n## 19. 搞懂prototype和 __proto__\n\n### javascript继承的本质\n\n一个对象 A的__proto__属性指向的那个对象B，B就是 A 的原型对象（或者叫父对象），对象 A 可以使用对象 B 中的属性和方法，同时也可以使用对象 B 的 原型对象C 上的属性和方法，以此递归，就是所谓的原型链。\n\n### new 操作到底做了什么\n\n\n\n\n\n\n"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"questions"},"buildId":"PNF1AQio7MGXtA91zf_VP","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8f31809deb7932dd0187.js"></script><script src="/_next/static/chunks/main-c6f966696d7d46f48c33.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" async=""></script><script src="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" async=""></script><script src="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" async=""></script><script src="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.102498c830e6881bc94f.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-13092b6d8cea2defd1b4.js" async=""></script><script src="/_next/static/PNF1AQio7MGXtA91zf_VP/_buildManifest.js" async=""></script><script src="/_next/static/PNF1AQio7MGXtA91zf_VP/_ssgManifest.js" async=""></script></body></html>