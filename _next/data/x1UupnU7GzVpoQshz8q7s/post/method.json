{"pageProps":{"frontmatter":{"title":"js常用方法集合（一）","date":"June 30, 2021","description":null},"post":{"content":"\n## Array\n\n1. 将输入值转化为数组\n\n``` javascript\nconst castArray = value => Array.isArray(value) ? value : [value];\n\n// Examples\ncastArray(1);               // [1]\ncastArray([1, 2, 3]);       // [1, 2, 3]\n```\n\n2. 判断数组是否为空\n\n``` javascript\nconst isEmpty = arr => Array.isArray(arr) && arr.length === 0;\n\n// Examples\nisEmpty(1);             // false\nisEmpty([]);            // true\nisEmpty([1, 2, 3]);     // false\n```\n\n3. 拷贝一个数组\n\n``` javascript\n// `arr` is an array\nconst clone = arr => arr.slice(0);\n\n// Or\nconst clone = arr => arr.concat([]);\n\n// Or\nconst clone = arr => [...arr];\n\n// Or\nconst clone = arr => Array.from(arr);\n\n// Or\nconst clone = arr => arr.map(v => v);\n```\n\n4. 对比两个数组是否一样\n   \n``` javascript\nconst isEqual = (arr1, arr2) => arr1.length === arr2.length && arr1.every((v, i) => v === arr2[i]);\n\n// Examples\nisEqual([1, 2, 3], [1, 2, 3]);      // true\nisEqual([1, 2, 3], [1, '2', 3]);    // false\n```\n\n5. 根据某个属性将数组转化为对象（属性作为key）\n\n``` javascript\nconst toObject = (arr, key) => arr.reduce((a, b) => ({...a, [b[key]]: b}), {});\n\n// Example\ntoObject(\n    [\n        { id: '1', name: 'Alpha', gender: 'Male' },\n        { id: '2', name: 'Bravo', gender: 'Male' },\n        { id: '3', name: 'Charlie', gender: 'Female' },\n    ],\n    'id'\n);\n/* \n{\n    '1': { id: '1', name: 'Alpha', gender: 'Male' },\n    '2': { id: '2', name: 'Bravo', gender: 'Male' },\n    '3': { id: '3', name: 'Charlie', gender: 'Female' },\n}\n*/\n```\n\n6. 找出数组中最大的值（Number）\n\n``` javascript\nconst indexOfMax = arr => arr.reduce((prev, v, i, a) => v > a[prev] ? i : prev, 0);\n\n// Examples\nindexOfMax([1, 3, 9, 7, 5]);        // 2\nindexOfMax([1, 3, 7, 7, 5]);        // 2\n```\n\n7. 根据属性找出数组中属性值最大的\n\n``` javascript\nconst maxBy = (arr, key) => arr.reduce((a, b) => a[key] >= b[key] ? a : b, {});\n\n// Example\nconst people = [\n    { name: 'Bar', age: 24 },\n    { name: 'Baz', age: 32 },\n    { name: 'Foo', age: 42 },\n    { name: 'Fuzz', age: 36 },\n];\nmaxBy(people, 'age');   // { name: 'Foo', age: 42 }\n```\n\n8. 数组去重\n\n``` javascript\nconst unique = arr => Array.from(new Set(arr));\n\n// Or\nconst unique = arr => arr.filter((el, i, array) => array.indexOf(el) === i);\n```\n\n9. 以属性值为key将数组转化成对象\n\n``` javascript\nconst groupBy = (arr, key) => arr.reduce((acc, item) => ((acc[item[key]] = [...(acc[item[key]] || []), item]), acc), {});\n\n// Example\ngroupBy([\n    { branch: 'audi', model: 'q8', year: '2019' },\n    { branch: 'audi', model: 'rs7', year: '2020' },\n    { branch: 'ford', model: 'mustang', year: '2019' },\n    { branch: 'ford', model: 'explorer', year: '2020' },\n    { branch: 'bmw', model: 'x7', year: '2020' },\n], 'branch');\n\n/*\n{\n    audi: [\n        { branch: 'audi', model: 'q8', year: '2019' },\n        { branch: 'audi', model: 'rs7', year: '2020' }\n    ],\n    bmw: [\n        { branch: 'bmw', model: 'x7', year: '2020' }\n    ],\n    ford: [\n        { branch: 'ford', model: 'mustang', year: '2019' },\n        { branch: 'ford', model: 'explorer', year: '2020' }\n    ],\n}\n*/\n```\n\n10. 根据属性值给数组排序\n\n``` javascript\nconst sortBy = (arr, k) => arr.concat().sort((a, b) => (a[k] > b[k]) ? 1 : ((a[k] < b[k]) ? -1 : 0));\n\n// Example\nconst people = [\n    { name: 'Foo', age: 42 },\n    { name: 'Bar', age: 24 },\n    { name: 'Fuzz', age: 36 },\n    { name: 'Baz', age: 32 },\n];\nsortBy(people, 'age');\n\n// returns\n//  [\n//      { name: 'Bar', age: 24 },\n//      { name: 'Baz', age: 32 },\n//      { name: 'Fuzz', age: 36 },\n//      { name: 'Foo', age: 42 },\n//  ]\n```\n\n## DOM\n\n1. 判断是否为某个元素的子节点\n\n``` javascript\nconst isDescendant = (child, parent) => parent.contains(child);\n```\n\n2. 判断当前元素是否是Focus状态\n\n``` javascript\nconst isFocus = ele => ele === document.activeElement;\n```\n\n3. 判断页面是否滑到底部\n\n``` javascript\nconst isAtBottom = () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;\n```\n\n4. 当前浏览器判断\n\n``` javascript\n\n// IE\nconst isIE = !!document.documentMode;\n\n// Chrome\nconst isChrome = !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);\n\n// macOS browser\nconst isMacBrowser = /Mac|iPod|iPhone|iPad/.test(navigator.platform);\n```\n\n5. 获取用户选中的文本\n\n``` javascript\nconst getSelectedText = () => window.getSelection().toString();\n```\n\n6. 隐藏元素\n  \n``` javascript\nconst hide = ele => ele.style.display = 'none';\n\n// Or\nconst hide = ele => ele.style.visibility = 'hidden';\n\n// Or\nconst hide = ele => ele.hidden = true;\n```\n\n7. 将元素插入某个元素之后\n\n``` javascript\nconst insertAfter = (ele, anotherEle) => anotherEle.parentNode.insertBefore(ele, anotherEle.nextSibling);\n\n// Or\nconst insertAfter = (ele, anotherEle) => anotherEle.insertAdjacentElement('afterend', ele);\n```\n\n8. 跳转页面\n\n``` javascript\nconst goTo = url => location.href = url;\n```\n\n9. 重新加载当前页\n\n``` javascript\nconst reload = () => location.reload();\n\n// Or\nconst reload = () => (location.href = location.href);\n```\n\n10. 替换元素\n\n``` javascript\nconst replace = (ele, newEle) => ele.parentNode.replaceChild(newEle, ele);\n```\n\n11. 回到页面顶部\n\n``` javascript\nconst goToTop = () => window.scrollTo(0, 0);\n```","excerpt":""},"previousPost":{"slug":"applyMiddleware","frontmatter":{"title":"redux源码系列之applyMiddleware","date":"June 28, 2021","description":null},"excerpt":"","content":"\n终于来到 **applyMiddleware** 部分，理解了 [**compose**](https://xudongdong.site/post/compose) 和 [**Currying**](https://xudongdong.site/post/currying)，这部分源码也变得很好理解\n\n这个方法是用来应用中间件的，用过 **node** 的同学应该比较了解，中间件我的理解类似于插件，一般为了避免系统框架过于臃肿，我们把常用的功能剥离开来，以中间件的形式插入到框架中来实现复杂的应用处理\n\n我们首先看下 **applyMiddleware** 的用法\n\n``` js\nimport { applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\n\nconst store = createStore(reducer, applyMiddleware(thunk, logger))\n```\n\n**createStore** 内部的调用\n\n``` js\nfunction createStore(reducer, preloadedState, enhancer) {\n  // 传入参数的判断\n  // ...\n\n  // 参数中enhancer function存在，一般是指applyMiddleware()\n  if (typeof enhancer !== \"undefined\" && typeof enhancer === \"function\") {\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  // 省略\n}\n```\n\n由此可以得出 **applyMiddleware** 的 **API** 调用\n\n``` js\napplyMiddleware(thunk, logger)(createStore)(reducer, preloadedState);\n\n// applyMiddleware(...middlewares)(createStore)(reducer, preloadedState);\n```\n\n结合源码\n\n我们将源码中 **TS** 部分去除，得出函数主体代码\n\n``` javascript\nimport { compose } from \"./compose\";\n\nfunction applyMiddleware(...middlewares) {\n  // use Currying function\n  return (createStore) => (reducer, preloadedState) => {\n    // 获取store\n    const store = createStore(reducer, preloadedState);\n    // 初始化dispatch\n    let dispatch = () => {\n      // 在dispatch完成正在赋值之前，调用会报错\n      throw new Error(\"目前还不能使用dispatch\")\n    }\n\n    // 给每个中间件的默认传参：getState，dispatch\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    }\n    \n    // 加入默认参数后的中间件chain\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // 对chain做compose操作，并赋值给dispatch\n    dispatch = compose(...chain)(store.dispatch)\n  }\n\n  // 返回store的属性和dispatch\n  return {\n    ...store,\n    dispatch\n  }\n}\n```\n\n主要难以理解的部分还是 **compose** 这一块\n\n我们拿两个中间件做解析\n\n``` javascript\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\n\napplyMiddleware(thunk, logger)(createStore)(reducer, preloadedState);\n\n// applyMiddleware chain部分\nconst middlewareAPI = { getState, dispatch }\n\nconst chain = [thunk, logger].map(middleware => middleware(middlewareAPI))\n// const chain = [thunk(middlewareAPI), logger(middlewareAPI)]\n// const chain = [thunk({ getState, dispatch }), logger({ getState, dispatch })]\n\n// applyMiddleware compose dispatch部分\ndispatch = compose(...chain)(store.dispatch)\n// dispatch = compose(thunk({ getState, dispatch }), logger({ getState, dispatch }))(store.dispatch)\n\n// 根据 compose 代码可转化为\n// dispatch = thunk({ getState, dispatch })(logger({ getState, dispatch })(store.dispatch))\n```\n\n代码到这边我们需要结合 **redux-thunk** 源码继续解析了\n\n``` js\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => (next) => (action) => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n```\n\n把\n``` js\ndispatch = thunk({ getState, dispatch })(logger({ getState, dispatch })(store.dispatch))\n```\n\n放到 **thunk** 中\n\n``` js\ndispatch = ({ getState, dispatch }) => {\n  return ({ getState, dispatch }) => (logger({ getState, dispatch })(store.dispatch)) => (action) => {\n\n    // 如果有异步action，会先执行异步action，在执行传进来的logger function\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return logger({ getState, dispatch })(store.dispatch)(action);\n  }\n}\n```\n\n应用了 **thunk** 和 **logger** 的 **redux** 应用，会先执行异步 **action**，在执行 **logger** 中间件。\n\n从代码上看，**applyMiddleware** 最主要的作用就是对原始的 **dispatch** 方法进行了重新赋值，并将它与 **store** 的属性返回。\n\n\n## 参考\n- [redux-thunk](https://github.com/reduxjs/redux-thunk/blob/master/src/index.js)\n\n"},"nextPost":{"slug":"js","frontmatter":{"title":"面试题集合（JS篇）","date":"June 30, 2021","description":null},"excerpt":"","content":"\n1. infinity代表什么数据\n\n在JS中Infinity用于表示无穷大的数值，且不是常量，即无法明确表示它到底有多大。可以通过isFinite(val)判断当前数字是否是无穷大，函数返回true表示不是无穷大，返回false表示是无穷大。\n\n\n2. 如何计算动画的帧率（FPS）\n\n- 可以借助requestAnimationFrame API，requestAnimationFrame 使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。\n\n- requestAnimationFrame的回调函数执行次数通常与浏览器屏幕刷新次数相匹配，而利用这个API实现动画的原理就是回调函数内再次调用requestAnimationFrame，所以页面不断重绘时，然后检测1秒内requestAnimationFrame调用的次数，就是当前的FPS\n\n\n3. 请说说new String(\"A\")和String(\"A\")分别返回的结果，请解释为什么\n\nnew String(\"A\") :\n返回类型：引用类型，堆内存存储\n返回值：字符串对象\n\nString(\"A”) ：\n返回类型：基本类型，栈内存存储\n返回值：字符串值\n\n4. 请通过reduce函数实现一维数组的求和\n\n``` javascript\nconst sum = arr => arr.reduce((a, b) => a + b)\n```\n\n5. 请说说严格模式下的this指向\n\n- 在严格模式下，在全局作用域中，this指向window对象\n- 在严格模式下，函数中的this等于undefined\n- 在严格模式下，对象的函数中的this指向调用函数的对象实例\n- 在严格模式下，构造函数中的this指向构造函数创建的对象实例。\n- 在严格模式下，在事件处理函数中，this指向触发事件的目标对象。\n\n6. 图片懒加载原理\n   \n图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的\n\n- 拿到所有的图片 dom 。\n- 遍历每个图片判断当前图片是否到了可视区范围内。\n- 如果到了就设置图片的 src 属性。\n- 绑定 window 的 scroll 事件，对其进行事件监听（搭配节流）。\n\n7. 懒加载和预加载\n\n两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n8. 如何区分返回内容是文件流还是json数据\n\n``` javascript\nawait (await fetch(url)).blob();\n// Blob {size: 100, type: \"application/json\"}\n// Blob {size: 73226, type: \"image/jpeg\"}\n```\n\n9. 写一个方法判断js的方法是内置的还是自定义的\n\ntoString一下\n``` javascript\nfunction isNative (f) {\n    return typeof f === 'function' && /native code/.test(f.toString())\n}\n```\n\n10. 微任务与宏任务\n\n- JavaScript是单线程的语言\n- Event Loop是javascript的执行机制\n\n![interview-js-event-loop](interview-js-event-loop.jpeg)\n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数\n- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\njs异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数，也就是说‘同一层’既有微任务也有宏任务的时候，先执行微任务\n\n``` javascript\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n```"}},"__N_SSG":true}