{"pageProps":{"frontmatter":{"title":"面试题集合（手撕代码篇）","date":"July 2, 2021","description":null},"post":{"content":"\n  \n1. 手写 bind、call、apply\n\n``` javascript\n// call\nFunction.prototype.myCall = (content) => {\n  content = content || window;\n  content.fn = this;\n  const args = [...arguments].slice(1);\n  const result = content.fn(args);\n  delete content.fn;\n  return result;\n}\n\n// apply\nFunction.prototype.myApply = (content) => {\n  content = content || window;\n  content.fn = this;\n  let result\n  if (arguments[1] && Array.isArray(arguments[1])) {\n    if (arguments[1].length === 1) {\n      result = content.fn(...arguments[1])\n    } else {\n      result = content.fn()\n    }\n  }\n  delete content.fn\n  return result\n}\n\n// bind\nFunction.prototype.myBind = (content) => {\n  content = content || window;\n  content.fn = this;\n  const args = [...arguments].slice(1);\n  return () => {\n    content.fn(args)\n  }\n}\n```\n\n2. 手写防抖节流\n   \n   防抖\n   ``` javascript\n    const debounce = (fn, delay) => {\n      let timeout = null;\n      return () => {\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n          fn.call(this, arguments)\n        }, delay)\n      }\n    }\n   ```\n   节流\n   ``` javascript\n    const throttle = (fn, delay) => {\n      let canRun = true;\n      if (!canRun) {\n        return\n      }\n      canRun = false;\n      setTimeout(() => {\n        fn.call(this. arguments);\n        canRun = true;\n      }, delay);\n    }\n   ```\n\n3. 手写数组flat\n\n4. 写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal\n\n``` javascript\nfunction mySetInterVal(fn, a, b) {\n  this.a = a;\n  this.b = b;\n  this.time = 0;\n  this.handle = -1;\n  this.start = () => {\n    this.handle = setTimeout(() => {\n      fn();\n      this.time++;\n      this.start();\n    }, this.a + this.time * this.b);\n  }\n\n  this.stop = () => {\n    clearTimeout(this.handle);\n    this.time = 0;\n  }\n}\n\nvar a = new mySetInterVal(() => {console.log('123')},1000, 2000 );\na.start();\na.stop();\n```\n\n5. 斐波那契数列\n   \n``` javascript\nconst Fibonacci = (n) => {\n  if (n < 0) throw new Error('输入的数字不能小于0');\n  if (n < 2) return n;\n  return Fibonacci(n - 1) + Fibonacci(n - 2)\n}\n```\n\n6. 字符串出现的不重复最长长度\n   \n7. 实现 add(1)(2)(3)\n   \n``` javascript\nconst add = (a) => (b) => (c) => a + b + c;\n```","excerpt":""},"previousPost":{"slug":"framework","frontmatter":{"title":"面试题集合（框架篇）","date":"July 1, 2021","description":null},"excerpt":"","content":"\n1. 什么时候使用状态管理器（React）\n\n- state并不总是以单向的方式线性流动\n- 存在组件需要更新全局状态\n- 存在组件需要更新另一个组件的状态\n- 某个状态需要在全局使用或共享（例如角色权限等信息）\n\n2. redux-saga和redux-thunk有什么本质的区别\n\n**redux-thunk** 中 **dispatch** 可以接受一个函数作为参数，而 **redux-saga** 其实和原始的 **redux** 保持一致，**dispatch** 的只是一个对象(plain object),异步是通过saga文件中的 **generator** 函数来处理的\n\n3. React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化\n   \n- 优化资源加载（减少http请求，采用CDN静态资源，小图片base64）\n- 首屏考虑SSR\n- 图片使用懒加载\n- 相关资源的预加载\n- 关于可视化的显示可以加入骨架\n- 分chunk实现动态加载组件\n- Service worker做缓存\n- 开发中遍历要给组件加key\n- css勿嵌套多层\n- 不必要的dom标签用Fragments\n- 考虑redux的必要性\n  \n4. react 最新版本解决了什么问题 加了哪些东西\n5. React 事件绑定原理\n   \n   React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n\n6. webpack 做过哪些优化，开发效率方面、打包策略方面等等\n   \n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/25)\n\n7. 说一下 react-fiber\n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/33)"},"nextPost":{"slug":"js","frontmatter":{"title":"面试题集合（JS篇）","date":"July 2, 2021","description":null},"excerpt":"","content":"\n1. infinity代表什么数据\n\n  在JS中Infinity用于表示无穷大的数值，且不是常量，即无法明确表示它到底有多大。可以通过isFinite(val)判断当前数字是否是无穷大，函数返回true表示不是无穷大，返回false表示是无穷大。\n\n\n2. 如何计算动画的帧率（FPS）\n\n- 可以借助requestAnimationFrame API，requestAnimationFrame 使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。\n\n- requestAnimationFrame的回调函数执行次数通常与浏览器屏幕刷新次数相匹配，而利用这个API实现动画的原理就是回调函数内再次调用requestAnimationFrame，所以页面不断重绘时，然后检测1秒内requestAnimationFrame调用的次数，就是当前的FPS\n\n\n3. 请说说new String(\"A\")和String(\"A\")分别返回的结果，请解释为什么\n\n  new String(\"A\") :\n  返回类型：引用类型，堆内存存储\n  返回值：字符串对象\n\n  String(\"A”) ：\n  返回类型：基本类型，栈内存存储\n  返回值：字符串值\n\n4. 请通过reduce函数实现一维数组的求和\n\n``` javascript\nconst sum = arr => arr.reduce((a, b) => a + b)\n```\n\n5. 请说说严格模式下的this指向\n\n- 在严格模式下，在全局作用域中，this指向window对象\n- 在严格模式下，函数中的this等于undefined\n- 在严格模式下，对象的函数中的this指向调用函数的对象实例\n- 在严格模式下，构造函数中的this指向构造函数创建的对象实例。\n- 在严格模式下，在事件处理函数中，this指向触发事件的目标对象。\n\n6. 图片懒加载原理\n   \n  图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的\n\n- 拿到所有的图片 dom 。\n- 遍历每个图片判断当前图片是否到了可视区范围内。\n- 如果到了就设置图片的 src 属性。\n- 绑定 window 的 scroll 事件，对其进行事件监听（搭配节流）。\n\n7. 懒加载和预加载\n\n  两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n8. 如何区分返回内容是文件流还是json数据\n\n``` javascript\nawait (await fetch(url)).blob();\n// Blob {size: 100, type: \"application/json\"}\n// Blob {size: 73226, type: \"image/jpeg\"}\n```\n\n9. 写一个方法判断js的方法是内置的还是自定义的\n\ntoString一下\n``` javascript\nfunction isNative (f) {\n    return typeof f === 'function' && /native code/.test(f.toString())\n}\n```\n\n10. 微任务与宏任务\n\n- JavaScript是单线程的语言\n- Event Loop是javascript的执行机制\n\n![interview-js-event-loop](interview-js-event-loop.jpeg)\n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数\n- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n  js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数，也就是说‘同一层’既有微任务也有宏任务的时候，先执行微任务\n\n``` javascript\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n```\n\n11. 函数的方法 call()、apply()、bind()的区别\n\n  改变函数执行上下文，也就是改变this的指向\n\n- call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。\n- call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n\n12. 前端性能优化\n- 减少 HTTP 请求\n- 使用 HTTP2\n- 使用服务端渲染\n  \n  客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\n  服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\n- 静态资源使用 CDN\n- 将 CSS 放在文件头部，JavaScript 文件放在底部\n- 使用字体图标 iconfont 代替图片图标\n- 善用缓存，不重复加载相同的资源\n- 压缩文件（js，css，图片）\n- 图片优化（懒加载，base64）\n- 分chunk，大的库考虑用CDN（react，router等）\n- 使用事件委托\n- if-else 对比 switch\n  \n  当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\n- 使用 Web Workers\n- 降低 CSS 选择器的复杂性（勿嵌套多层）\n\n13. 什么是防抖和节流，应用场景是啥\n    \n    都是用于限制函数被频繁调用\n\n    **防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**\n\n    场景：有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。\n\n    **节流：任务频繁触发的情况下，指定时间间隔内只会执行一次任务。**\n\n    场景：懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取；双十一抢商品\n\n14. 实现链式调用\n    \n链式调用的核心就在于调用完的方法将自身实例返回\n\n``` javascript\nfunction Class1() {\n    console.log('初始化')\n}\nClass1.prototype.method = function(param) {\n    console.log(param)\n    return this\n}\nlet cl = new Class1()\n//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。\ncl.method('第一次调用').method('第二次链式调用').method('第三次链式调用')\n```\n\n15. 手写Promise\n    \n16. 实现 Promise.all"}},"__N_SSG":true}