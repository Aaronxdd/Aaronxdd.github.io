{"pageProps":{"frontmatter":{"title":"算法题（简单系列）","date":"June 30, 2021","description":null},"post":{"content":"\n### 1. 两数之和\n\n#### 题目描述\n\n给定一个整数数组 **nums** 和一个目标值 **target**，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n#### 示例\n\n``` js\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n````\n\n#### 代码实现\n\n``` javascript\nconst findTotal = (nums, target) => {\n  for(let i = 0; i < nums.length; i++) {\n    if (nums.includes(target-nums[i])) {\n      return [i, nums.indexOf(target-nums[i])];\n    }\n  }\n}\n```\n\n\n### 2. 字符串出现的不重复最长长度\n","excerpt":""},"previousPost":{"slug":"method","frontmatter":{"title":"js常用方法集合（一）","date":"June 30, 2021","description":null},"excerpt":"","content":"\n## Array\n\n1. 将输入值转化为数组\n\n``` javascript\nconst castArray = value => Array.isArray(value) ? value : [value];\n\n// Examples\ncastArray(1);               // [1]\ncastArray([1, 2, 3]);       // [1, 2, 3]\n```\n\n2. 判断数组是否为空\n\n``` javascript\nconst isEmpty = arr => Array.isArray(arr) && arr.length === 0;\n\n// Examples\nisEmpty(1);             // false\nisEmpty([]);            // true\nisEmpty([1, 2, 3]);     // false\n```\n\n3. 拷贝一个数组\n\n``` javascript\n// `arr` is an array\nconst clone = arr => arr.slice(0);\n\n// Or\nconst clone = arr => arr.concat([]);\n\n// Or\nconst clone = arr => [...arr];\n\n// Or\nconst clone = arr => Array.from(arr);\n\n// Or\nconst clone = arr => arr.map(v => v);\n```\n\n4. 对比两个数组是否一样\n   \n``` javascript\nconst isEqual = (arr1, arr2) => arr1.length === arr2.length && arr1.every((v, i) => v === arr2[i]);\n\n// Examples\nisEqual([1, 2, 3], [1, 2, 3]);      // true\nisEqual([1, 2, 3], [1, '2', 3]);    // false\n```\n\n5. 根据某个属性将数组转化为对象（属性作为key）\n\n``` javascript\nconst toObject = (arr, key) => arr.reduce((a, b) => ({...a, [b[key]]: b}), {});\n\n// Example\ntoObject(\n    [\n        { id: '1', name: 'Alpha', gender: 'Male' },\n        { id: '2', name: 'Bravo', gender: 'Male' },\n        { id: '3', name: 'Charlie', gender: 'Female' },\n    ],\n    'id'\n);\n/* \n{\n    '1': { id: '1', name: 'Alpha', gender: 'Male' },\n    '2': { id: '2', name: 'Bravo', gender: 'Male' },\n    '3': { id: '3', name: 'Charlie', gender: 'Female' },\n}\n*/\n```\n\n6. 找出数组中最大的值（Number）\n\n``` javascript\nconst indexOfMax = arr => arr.reduce((prev, v, i, a) => v > a[prev] ? i : prev, 0);\n\n// Examples\nindexOfMax([1, 3, 9, 7, 5]);        // 2\nindexOfMax([1, 3, 7, 7, 5]);        // 2\n```\n\n7. 根据属性找出数组中属性值最大的\n\n``` javascript\nconst maxBy = (arr, key) => arr.reduce((a, b) => a[key] >= b[key] ? a : b, {});\n\n// Example\nconst people = [\n    { name: 'Bar', age: 24 },\n    { name: 'Baz', age: 32 },\n    { name: 'Foo', age: 42 },\n    { name: 'Fuzz', age: 36 },\n];\nmaxBy(people, 'age');   // { name: 'Foo', age: 42 }\n```\n\n8. 数组去重\n\n``` javascript\nconst unique = arr => Array.from(new Set(arr));\n\n// Or\nconst unique = arr => arr.filter((el, i, array) => array.indexOf(el) === i);\n```\n\n9. 以属性值为key将数组转化成对象\n\n``` javascript\nconst groupBy = (arr, key) => arr.reduce((acc, item) => ((acc[item[key]] = [...(acc[item[key]] || []), item]), acc), {});\n\n// Example\ngroupBy([\n    { branch: 'audi', model: 'q8', year: '2019' },\n    { branch: 'audi', model: 'rs7', year: '2020' },\n    { branch: 'ford', model: 'mustang', year: '2019' },\n    { branch: 'ford', model: 'explorer', year: '2020' },\n    { branch: 'bmw', model: 'x7', year: '2020' },\n], 'branch');\n\n/*\n{\n    audi: [\n        { branch: 'audi', model: 'q8', year: '2019' },\n        { branch: 'audi', model: 'rs7', year: '2020' }\n    ],\n    bmw: [\n        { branch: 'bmw', model: 'x7', year: '2020' }\n    ],\n    ford: [\n        { branch: 'ford', model: 'mustang', year: '2019' },\n        { branch: 'ford', model: 'explorer', year: '2020' }\n    ],\n}\n*/\n```\n\n10. 根据属性值给数组排序\n\n``` javascript\nconst sortBy = (arr, k) => arr.concat().sort((a, b) => (a[k] > b[k]) ? 1 : ((a[k] < b[k]) ? -1 : 0));\n\n// Example\nconst people = [\n    { name: 'Foo', age: 42 },\n    { name: 'Bar', age: 24 },\n    { name: 'Fuzz', age: 36 },\n    { name: 'Baz', age: 32 },\n];\nsortBy(people, 'age');\n\n// returns\n//  [\n//      { name: 'Bar', age: 24 },\n//      { name: 'Baz', age: 32 },\n//      { name: 'Fuzz', age: 36 },\n//      { name: 'Foo', age: 42 },\n//  ]\n```\n\n## DOM\n\n1. 判断是否为某个元素的子节点\n\n``` javascript\nconst isDescendant = (child, parent) => parent.contains(child);\n```\n\n2. 判断当前元素是否是Focus状态\n\n``` javascript\nconst isFocus = ele => ele === document.activeElement;\n```\n\n3. 判断页面是否滑到底部\n\n``` javascript\nconst isAtBottom = () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;\n```\n\n4. 当前浏览器判断\n\n``` javascript\n\n// IE\nconst isIE = !!document.documentMode;\n\n// Chrome\nconst isChrome = !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);\n\n// macOS browser\nconst isMacBrowser = /Mac|iPod|iPhone|iPad/.test(navigator.platform);\n```\n\n5. 获取用户选中的文本\n\n``` javascript\nconst getSelectedText = () => window.getSelection().toString();\n```\n\n6. 隐藏元素\n  \n``` javascript\nconst hide = ele => ele.style.display = 'none';\n\n// Or\nconst hide = ele => ele.style.visibility = 'hidden';\n\n// Or\nconst hide = ele => ele.hidden = true;\n```\n\n7. 将元素插入某个元素之后\n\n``` javascript\nconst insertAfter = (ele, anotherEle) => anotherEle.parentNode.insertBefore(ele, anotherEle.nextSibling);\n\n// Or\nconst insertAfter = (ele, anotherEle) => anotherEle.insertAdjacentElement('afterend', ele);\n```\n\n8. 跳转页面\n\n``` javascript\nconst goTo = url => location.href = url;\n```\n\n9. 重新加载当前页\n\n``` javascript\nconst reload = () => location.reload();\n\n// Or\nconst reload = () => (location.href = location.href);\n```\n\n10. 替换元素\n\n``` javascript\nconst replace = (ele, newEle) => ele.parentNode.replaceChild(newEle, ele);\n```\n\n11. 回到页面顶部\n\n``` javascript\nconst goToTop = () => window.scrollTo(0, 0);\n```"},"nextPost":{"slug":"data-structure","frontmatter":{"title":"数据结构笔记","date":"June 30, 2021","description":null},"excerpt":"","content":"\n## 存储方式\n\n### 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）\n\n散列表、栈、队列、堆、树、图等等各种数据结构都属于上层建筑，而数组和链表才是「结构基础」。\n\n### 两者优缺点\n\n**数组**\n\n1. 由于是连续存储，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间，访问数组元素的时间复杂度 O(1)；\n2. 但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。\n\n**链表**\n\n1. 因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；\n2. 如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。\n3. 但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。\n\n\n## 基本操作\n\n数据结构的基本操作无非遍历 + 访问，即增删改查；\n\n但是不同数据结构的增删改查的效率是不一样的，所以我们需要了解各数据结构的特性以便我们在不同场景下提高代码的性能。\n\n遍历 + 访问 分为两种形式：线性的和非线性的。\n\n线性：以for/while 迭代为代表\n\n非线性：以递归为代表\n\n\n"}},"__N_SSG":true}