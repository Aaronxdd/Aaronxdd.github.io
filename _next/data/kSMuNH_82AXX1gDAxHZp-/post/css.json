{"pageProps":{"frontmatter":{"title":"面试题集合（CSS篇）","date":"July 4, 2021","description":null},"post":{"content":"\n## 1. css 伪类与伪元素区别\n   \n### 伪类(pseudo-classes)\n\n其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。⽐如:hover :active :visited :link :visited :first-child :focus :lang等；由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。\n  \n### 伪元素(Pseudo-elements)\n\nDOM树没有定义的虚拟元素\n\n核⼼就是需要创建通常不存在于⽂档中的元素，⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器\n    \n### 伪类与伪元素的区别\n    \n表示⽅法\n\nCSS2 中伪类、伪元素都是以单冒号:表示,CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示，浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first�line, :first-letter 等)的单冒号写法。CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头定义不同\n\n伪类即假的类，可以添加类来达到效果\n\n伪元素即假元素，需要通过添加元素才能达到效果\n    \n总结:\n\n伪类和伪元素都是⽤来表示⽂档树以外的\"元素\"。伪类和伪元素分别⽤单冒号:和双冒号::来表示。伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类。\n\n### 相同之处：\n\n伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。\n  \n### 不同之处：\n    \n伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。","excerpt":""},"previousPost":{"slug":"framework","frontmatter":{"title":"面试题集合（框架篇）","date":"July 1, 2021","description":null},"excerpt":"","content":"\n## 1. 什么时候使用状态管理器（React）\n\n- state并不总是以单向的方式线性流动\n- 存在组件需要更新全局状态\n- 存在组件需要更新另一个组件的状态\n- 某个状态需要在全局使用或共享（例如角色权限等信息）\n\n## 2. redux-saga和redux-thunk有什么本质的区别\n\n**redux-thunk** 中 **dispatch** 可以接受一个函数作为参数，而 **redux-saga** 其实和原始的 **redux** 保持一致，**dispatch** 的只是一个对象(plain object),异步是通过saga文件中的 **generator** 函数来处理的\n\n## 3. React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化\n   \n- 优化资源加载（减少http请求，采用CDN静态资源，小图片base64）\n- 首屏考虑SSR\n- 图片使用懒加载\n- 相关资源的预加载\n- 关于可视化的显示可以加入骨架\n- 分chunk实现动态加载组件\n- Service worker做缓存\n- 开发中遍历要给组件加key\n- css勿嵌套多层\n- 不必要的dom标签用Fragments\n- 考虑redux的必要性\n  \n## 4. react 最新版本解决了什么问题 加了哪些东西\n## 5. React 事件绑定原理\n   \nReact并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n\n## 6. webpack 做过哪些优化，开发效率方面、打包策略方面等等\n   \n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/25)\n\n## 7. 说一下 react-fiber\n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/33)\n\n## 8. React 18的新特性\n\n- 新的 **ReactDOM.createRoot()** API（替换 **ReactDOM.render()**）\n- 新的 **startTransition** API（用于非紧急状态更新）\n- 渲染的自动批处理优化（主要解决异步回调中无法批处理的问题）\n- 支持 **React.lazy** 的 全新 SSR 架构（支持 **<Suspense>** 组件）"},"nextPost":{"slug":"write","frontmatter":{"title":"面试题集合（手撕代码篇）","date":"July 5, 2021","description":null},"excerpt":"","content":"\n  \n## 1. 手写 bind、call、apply\n\n``` javascript\n// call\nFunction.prototype.myCall = (content) => {\n  content = content || window;\n  content.fn = this;\n  const args = [...arguments].slice(1);\n  const result = content.fn(args);\n  delete content.fn;\n  return result;\n}\n\n// apply\nFunction.prototype.myApply = (content) => {\n  content = content || window;\n  content.fn = this;\n  let result\n  if (arguments[1] && Array.isArray(arguments[1])) {\n    if (arguments[1].length === 1) {\n      result = content.fn(...arguments[1])\n    } else {\n      result = content.fn()\n    }\n  }\n  delete content.fn\n  return result\n}\n\n// bind\nFunction.prototype.myBind = (content) => {\n  content = content || window;\n  content.fn = this;\n  const args = [...arguments].slice(1);\n  return () => {\n    content.fn(args)\n  }\n}\n```\n\n## 2. 手写防抖节流\n   \n   防抖\n   ``` javascript\n    const debounce = (fn, delay) => {\n      let timeout = null;\n      return () => {\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n          fn.call(this, arguments)\n        }, delay)\n      }\n    }\n   ```\n   节流\n   ``` javascript\n    const throttle = (fn, delay) => {\n      let canRun = true;\n      if (!canRun) {\n        return\n      }\n      canRun = false;\n      setTimeout(() => {\n        fn.call(this. arguments);\n        canRun = true;\n      }, delay);\n    }\n   ```\n\n## 3. 手写数组flat\n\n## 4. 写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal\n\n``` javascript\nfunction mySetInterVal(fn, a, b) {\n  this.a = a;\n  this.b = b;\n  this.time = 0;\n  this.handle = -1;\n  this.start = () => {\n    this.handle = setTimeout(() => {\n      fn();\n      this.time++;\n      this.start();\n    }, this.a + this.time * this.b);\n  }\n\n  this.stop = () => {\n    clearTimeout(this.handle);\n    this.time = 0;\n  }\n}\n\nvar a = new mySetInterVal(() => {console.log('123')},1000, 2000 );\na.start();\na.stop();\n```\n\n## 5. 斐波那契数列\n   \n``` javascript\nconst Fibonacci = (n) => {\n  if (n < 0) throw new Error('输入的数字不能小于0');\n  if (n < 2) return n;\n  return Fibonacci(n - 1) + Fibonacci(n - 2)\n}\n```\n   \n## 7. 实现 add(1)(2)(3)\n   \n``` javascript\nconst add = (a) => (b) => (c) => a + b + c;\n```\n\n## 8. 数据类型判断\n\ntypeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。\n\n``` javascript\nconst getType = (obj) => {\n  return Object.prototype.toString.call(obj).slice(8, -1);\n}\n```\n\n## 9. 数组扁平化\n    \n数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：\n\n``` javascript\n[1, [2, [3]]].flat(2)  // [1, 2, 3]\n```\n\n关键：递归\n\n``` javascript\nconst flatten = arr => {\n  let newArr = [];\n  for(let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      newArr.concat(flatten(arr[i]))\n      return\n    }\n    newArr.push(arr[i])\n  }\n  return neaArr;\n}\n```\n\n## 10. 深浅拷贝\n\n浅拷贝：只考虑对象类型\n\nES5版\n``` javascript\nfunction shallowCopy(obj) {\n  if (typeof obj !== 'object') return\n\n  let newObj = obj instanceof Array ? [] : {};\n\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = obj[i];\n    }\n  }\n\n  return newObj;\n}\n```\n\nES6版\n``` javascript\nconst shallowCopy = obj => Array.isArray(obj) ? [...obj] : {...obj}\n```\n\n深拷贝\n\n``` javascript\nconst deepClone = obj => {\n  if (typeof obj !== 'object') return;\n  let newObj = obj instanceof Array ? [] : {};\n  \n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (typeof obj[key] === 'object') {\n        newObj[key] = deepClone(obj[key]);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  return newObj;\n}\n```\n\n## 11. 解析 URL 参数为对象\n  \n``` javascript\nconst urlSearch = href => {\n  let obj = {};\n  const queryIndex = href.indexOf('?');\n  const urlOptions = href.slice(queryIndex + 1, href.length);\n  const options = urlOptions.split('&');\n  options.map(option => {\n    const equalIndex = option.indexOf('=');\n    obj[option.slice(0, equalIndex)] = option.slice(equalIndex + 1, option.length);\n  });\n  return obj;\n}\n```\n\n## 12. 字符串模板\n## 13. 实现柯里化（Currying）\n\n``` javascript\nfunction curry(fn) {\n    let judge = (...args) => {\n        if (args.length == fn.length) return fn(...args)\n        return (...arg) => judge(...args, ...arg)\n    }\n    return judge\n}\n```\n\n## 14. 手写AJAX\n\n``` js\nconst myAjax = (url) => {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState !== 4) return\n      if (xhr.status === 200) {\n        resolve(xhr.responseText)\n      } else {\n        reject(xhr.responseText)\n      }\n    }\n    xhr.send();\n  })\n}\n```\n\n## 15. 手写Promise\n\n``` javascript\nconst PADDING = \"PADDING\";\nconst FULFILLED = \"FULFILLED\";\nconst REJECTED = \"REJECTED\";\n\nclass MyPromise {\n  constructor(executor) {\n    this.status = PADDING;\n    this.value = undefined;\n    this.error = undefined;\n\n    let resolve = (value) => {\n      if (this.status === PADDING) {\n        this.value = value;\n        this.status = FULFILLED;\n      }\n    }\n\n    let reject = (error) => {\n      if (this.status === PADDING) {\n        this.error = error;\n        this.status = REJECTED;\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n      onFulfilled(this.value)\n    }\n\n    if (this.status === REJECTED) {\n      onRejected(this.error)\n    }\n  }\n}\n```\n    \n## 16. 实现 Promise.all\n  \n``` js\nconst promiseAll = (promises) => {\n  if (Array.isArray(promises)) {\n    throw new Error('the arguments must be an array !!!')\n  }\n  const promisesLength = promises.length;\n  let current = 0, result = [];\n  new Promise((resolve, reject) => {\n    promises.forEach((promise, i) => {\n      Promise.resolve(promise).then(value => {\n        current ++;\n        result[i] = value;\n        if (current === promisesLength) {\n          resolve(result)\n        }\n      }, error => reject(error))\n    })\n  })\n}\n```\n\n## 17. 手写模版字符串\n\n``` javascript\nconst render = (str, data) => {\n  const reg = /\\{\\{(\\w+)\\}\\}/;\n  if (reg.test(str)) {\n    const key = reg.exec(str)[1];\n    str = str.replace(reg, data[key]);\n    return render(str, data);\n  }\n  return str;\n} \n```"}},"__N_SSG":true}