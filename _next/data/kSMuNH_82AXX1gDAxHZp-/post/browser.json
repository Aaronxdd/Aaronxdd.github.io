{"pageProps":{"frontmatter":{"title":"面试题集合（浏览器篇）","date":"July 6, 2021","description":null},"post":{"content":"\n## 1. 浏览器存储\n\n### Cookie\n\n- 大小限制4k，超出会裁剪\n\n- HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）\n  \n- cookie 存储在客户端\n  \n  cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\n\n- cookie 是不可跨域的\n  \n### LocalStorage\n\n- 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据\n- 大小为5M左右\n- 仅在客户端使用，不和服务端进行通信\n\n### sessionStorage\n\n- 会话级别的浏览器存储（窗口关闭会清空）\n- 大小为5M左右\n- 仅在客户端使用，不和服务端进行通信\n  \n基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。\n\n### sessionStorage 、localStorage 和 cookie 之间的区别\n\n- 共同点：都是保存在浏览器端，且都遵循同源策略。\n- 不同点：在于生命周期与作用域的不同","excerpt":""},"previousPost":{"slug":"js","frontmatter":{"title":"面试题集合（JS篇）","date":"July 5, 2021","description":null},"excerpt":"","content":"\n## 1. infinity代表什么数据\n\n  在JS中Infinity用于表示无穷大的数值，且不是常量，即无法明确表示它到底有多大。可以通过isFinite(val)判断当前数字是否是无穷大，函数返回true表示不是无穷大，返回false表示是无穷大。\n\n\n## 2. 如何计算动画的帧率（FPS）\n\n- 可以借助requestAnimationFrame API，requestAnimationFrame 使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。\n\n- requestAnimationFrame的回调函数执行次数通常与浏览器屏幕刷新次数相匹配，而利用这个API实现动画的原理就是回调函数内再次调用requestAnimationFrame，所以页面不断重绘时，然后检测1秒内requestAnimationFrame调用的次数，就是当前的FPS\n\n\n## 3. 请说说new String(\"A\")和String(\"A\")分别返回的结果，请解释为什么\n\n- new String(\"A\") :\n  \n  返回类型：引用类型，堆内存存储\n  返回值：字符串对象\n\n- String(\"A”) ：\n  \n  返回类型：基本类型，栈内存存储\n  返回值：字符串值\n\n## 4. 请通过reduce函数实现一维数组的求和\n\n``` javascript\nconst sum = arr => arr.reduce((a, b) => a + b)\n```\n\n## 5. 请说说严格模式下的this指向\n\n- 在严格模式下，在全局作用域中，this指向window对象\n- 在严格模式下，函数中的this等于undefined\n- 在严格模式下，对象的函数中的this指向调用函数的对象实例\n- 在严格模式下，构造函数中的this指向构造函数创建的对象实例。\n- 在严格模式下，在事件处理函数中，this指向触发事件的目标对象。\n\n## 6. 图片懒加载原理\n   \n  图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的\n\n- 拿到所有的图片 dom 。\n- 遍历每个图片判断当前图片是否到了可视区范围内。\n- 如果到了就设置图片的 src 属性。\n- 绑定 window 的 scroll 事件，对其进行事件监听（搭配节流）。\n\n``` js\nlet imgList = [...document.querySelectorAll('img')]\nlet length = imgList.length\n\n// 修正错误，需要加上自执行\n- const imgLazyLoad = function() {\n+ const imgLazyLoad = (function() {\n    let count = 0\n    \n   return function() {\n        let deleteIndexList = []\n        imgList.forEach((img, index) => {\n            let rect = img.getBoundingClientRect()\n            if (rect.top < window.innerHeight) {\n                img.src = img.dataset.src\n                deleteIndexList.push(index)\n                count++\n                if (count === length) {\n                    document.removeEventListener('scroll', imgLazyLoad)\n                }\n            }\n        })\n        imgList = imgList.filter((img, index) => !deleteIndexList.includes(index))\n   }\n- }\n+ })()\n\n// 这里最好加上节流处理\ndocument.addEventListener('scroll', imgLazyLoad)\n\n```\n\n## 7. 懒加载和预加载\n\n  两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n## 8. 如何区分返回内容是文件流还是json数据\n\n``` javascript\nawait (await fetch(url)).blob();\n// Blob {size: 100, type: \"application/json\"}\n// Blob {size: 73226, type: \"image/jpeg\"}\n```\n\n## 9. 写一个方法判断js的方法是内置的还是自定义的\n\ntoString一下\n``` javascript\nfunction isNative (f) {\n    return typeof f === 'function' && /native code/.test(f.toString())\n}\n```\n\n## 10. 微任务与宏任务\n\n- JavaScript是单线程的语言\n- Event Loop是javascript的执行机制\n\n![interview-js-event-loop](interview-js-event-loop.jpeg)\n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数\n- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n  js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数，也就是说‘同一层’既有微任务也有宏任务的时候，先执行微任务\n\n``` javascript\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n```\n\n## 11. 函数的方法 call()、apply()、bind()的区别\n\n### 改变函数执行上下文，也就是改变this的指向\n\n- call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。\n- call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n\n## 12. 前端性能优化\n- 减少 HTTP 请求\n- 使用 HTTP2\n- 使用服务端渲染\n  \n  客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\n  服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\n\n- 静态资源使用 CDN\n- 将 CSS 放在文件头部，JavaScript 文件放在底部\n- 使用字体图标 iconfont 代替图片图标\n- 善用缓存，不重复加载相同的资源\n- 压缩文件（js，css，图片）\n- 图片优化（懒加载，base64）\n- 分chunk，大的库考虑用CDN（react，router等）\n- 使用事件委托\n- if-else 对比 switch\n  \n  当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\n- 使用 Web Workers\n- 降低 CSS 选择器的复杂性（勿嵌套多层）\n\n## 13. 什么是防抖和节流，应用场景是啥\n    \n    都是用于限制函数被频繁调用\n\n    **防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**\n\n    场景：有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。\n\n    **节流：任务频繁触发的情况下，指定时间间隔内只会执行一次任务。**\n\n    场景：懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取；双十一抢商品\n\n## 14. 实现链式调用\n    \n链式调用的核心就在于调用完的方法将自身实例返回\n\n``` javascript\nfunction Class1() {\n    console.log('初始化')\n}\nClass1.prototype.method = function(param) {\n    console.log(param)\n    return this\n}\nlet cl = new Class1()\n//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。\ncl.method('第一次调用').method('第二次链式调用').method('第三次链式调用')\n```\n    \n## 15. 继承\n    \n**原型链继承**\n\n``` javascript\nfunction Animal() {\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getColor = function() {\n    return this.colors\n}\nfunction Dog() {}\nDog.prototype =  new Animal()\n\nlet dog1 = new Dog()\ndog1.colors.push('brown')\nlet dog2 = new Dog()\nconsole.log(dog2.colors)  // ['black', 'white', 'brown']\n```\n\n**问题**\n\n- 原型中的属性会被共享\n- 实例化时无法给父类构造函数传参\n  \n**借用构造函数实现继承**\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.getName = function() {\n        return this.name\n    }\n}\nfunction Dog(name) {\n    Animal.call(this, name)\n}\n```\n借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以**会导致每次创建子类实例都会创建一遍方法**。\n\n**组合继承**\n\n组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getName = function() {\n    return this.name\n}\nfunction Dog(name, age) {\n    Animal.call(this, name)\n    this.age = age\n}\nDog.prototype =  new Animal()\nDog.prototype.constructor = Dog\n\nlet dog1 = new Dog('奶昔', 2)\ndog1.colors.push('brown')\nlet dog2 = new Dog('哈赤', 1)\nconsole.log(dog2) // { name: \"哈赤\", colors: [\"black\", \"white\"], age: 1 }\n```\n\n## 16. js中的堆栈\n    \n### 栈数据结构\n\n- 栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。\n- 栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。\n\n### 堆数据结构\n\n- 堆是一种经过排序的树形数据结构，每个结点都有一个值。\n- 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。\n\n### 变量类型与内存的关系\n\n#### 基本数据类型\n\nSting、Number、Boolean、null、undefined、Symbol\n\n- 基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。\n\n- 引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址\n"},"nextPost":{"slug":"easy","frontmatter":{"title":"算法题（简单系列）","date":"July 6, 2021","description":null},"excerpt":"","content":"\n### 1. 两数之和\n\n#### 题目描述\n\n给定一个整数数组 **nums** 和一个目标值 **target**，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n#### 示例\n\n``` javascript\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n````\n\n#### 代码实现\n\n``` javascript\nconst findTotal = (nums, target) => {\n  for(let i = 0; i < nums.length; i++) {\n    if (nums.includes(target-nums[i])) {\n      return [i, nums.indexOf(target-nums[i])];\n    }\n  }\n}\n```\n\n\n### 2. 整数反转\n\n#### 题目描述\n\n![reverse-integer](reverse-integer.jpeg)\n\n\n#### 代码实现\n\n``` javascript\nconst reverse = (x) => {\n  let result = 0;\n  while (x !== 0) {\n    result = result * 10 + (x % 10);\n    x = Math.floor(x / 10);\n  }\n\n  if (result < -Math.pow(2, 31) || result > Math.pow(2, 31) - 1) {\n    return 0;\n  }\n  return result;\n};\n```\n\n### 3. 合并两个有序链表\n\n#### 题目描述\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n#### 示例1\n\n![merge-two-sorted-lists](merge-two-sorted-lists.jpeg)\n\n``` javascript\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n#### 示例2\n\n``` javascript\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n#### 示例3\n\n``` javascript\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n#### 提示\n\n- 两个链表的节点数目范围是 [0, 50]\n- -100 <= Node.val <= 100\n- l1 和 l2 均按 非递减顺序 排列\n\n``` javascript\n// 例如 现有两个链表\nconst ListNode1 = {\n  value: 0,\n  next: {\n    value: 2,\n    next: {\n      value: 4,\n      next: null\n    }\n  }\n}\n\nconst ListNode2 = {\n  value: 1,\n  next: {\n    value: 3,\n    next: {\n      value: 5,\n      next: null\n    }\n  }\n}\n```\n\n#### 实现\n\n``` javascript\nconst mergeTwoLists = (l1, l2) => {\n  if (l1 === null) {\n    return l2\n  }\n  if (l2 === null) {\n    return l1\n  }\n  if (l1.value < l2.value) {\n    l1.next = mergeTwoLists(l1.next, l2)\n    return l1\n  }\n  if (l2.value < l1.value) {\n    l2.next = mergeTwoLists(l2.next, l1)\n    return l2\n  }\n}\n```\n\n### 4. 最大子序和\n\n#### 题目描述\n\n给定一个整数数组 **nums** ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n#### 示例1\n\n``` javascript\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n```\n\n#### 示例2\n\n``` javascript\n输入：nums = [1]\n输出：1\n```\n\n#### 示例3\n\n``` javascript\n输入：nums = [0]\n输出：0\n```\n\n#### 示例4\n\n``` javascript\n输入：nums = [-1]\n输出：-1\n```\n\n#### 示例5\n\n``` javascript\n输入：nums = [-100000]\n输出：-100000\n```\n\n#### 提示\n- 1 <= nums.length <= 3 * 104\n- -105 <= nums[i] <= 105\n\n``` javascript\nconst maxSubArray = (nums) => {\n  let pre = 0;\n  let max = nums[0];\n  nums.forEach(x => {\n    pre = Math.max(pre + x, x);\n    max = Math.max(max, pre);\n  });\n  return max;\n};\n```\n\n### 5. 反转链表\n\n#### 题目描述\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n#### 示例:\n\n``` javascript\nconst ListNode = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: {\n          value: 5,\n          next: null\n        }\n      }\n    }\n  }\n}\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n```\n\n#### 限制：\n\n``` javascript\n0 <= 节点个数 <= 5000\n```\n\n``` javascript\nconst reverseList = (head) => {\n  let pre = null;\n  let cur = head;\n  while(cur) {\n    const next = cur.next;\n    cur.next = pre;\n    pre = cur;\n    cur = next;\n  }\n  return pre;\n}\n```\n\n"}},"__N_SSG":true}