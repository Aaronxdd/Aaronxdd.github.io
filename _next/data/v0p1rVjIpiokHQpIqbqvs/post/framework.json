{"pageProps":{"frontmatter":{"title":"面试题集合（框架篇）","date":"July 1, 2021","description":null},"post":{"content":"\n1. 什么时候使用状态管理器（React）\n\n- state并不总是以单向的方式线性流动\n- 存在组件需要更新全局状态\n- 存在组件需要更新另一个组件的状态\n- 某个状态需要在全局使用或共享（例如角色权限等信息）\n\n2. redux-saga和redux-thunk有什么本质的区别\n\n**redux-thunk** 中 **dispatch** 可以接受一个函数作为参数，而 **redux-saga** 其实和原始的 **redux** 保持一致，**dispatch** 的只是一个对象(plain object),异步是通过saga文件中的 **generator** 函数来处理的\n\n3. React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化\n   \n- 优化资源加载（减少http请求，采用CDN静态资源，小图片base64）\n- 首屏考虑SSR\n- 图片使用懒加载\n- 相关资源的预加载\n- 关于可视化的显示可以加入骨架\n- 分chunk实现动态加载组件\n- Service worker做缓存\n- 开发中遍历要给组件加key\n- css勿嵌套多层\n- 不必要的dom标签用Fragments\n- 考虑redux的必要性\n  \n4. react 最新版本解决了什么问题 加了哪些东西\n5. React 事件绑定原理\n   \n   React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n\n6. webpack 做过哪些优化，开发效率方面、打包策略方面等等\n   \n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/25)\n\n7. 说一下 react-fiber\n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/33)\n\n8. React 18的新特性\n\n- 新的 **ReactDOM.createRoot()** API（替换 **ReactDOM.render()**）\n- 新的 **startTransition** API（用于非紧急状态更新）\n- 渲染的自动批处理优化（主要解决异步回调中无法批处理的问题）\n- 支持 **React.lazy** 的 全新 SSR 架构（支持 **<Suspense>** 组件）","excerpt":""},"previousPost":{"slug":"http","frontmatter":{"title":"面试题集合（网络篇）","date":"July 1, 2021","description":null},"excerpt":"","content":"\n## 1. TCP/IP 四层网络模型\n\n第一层：应用层，主要有负责web浏览器的 **HTTP** 协议， 文件传输的 **FTP** 协议，负责电子邮件的 **SMTP** 协议，负责域名系统的 **DNS** 等。\n第二层：传输层，主要是有可靠传输的 **TCP** 协议，特别高效的 **UDP** 协议。主要负责传输应用层的数据包。\n第三层：网络层，主要是 **IP** 协议。主要负责寻址（找到目标设备的位置）\n第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。\n\n## 2. 用户输入url到页面展示的过程\n   \n- DNS解析\n  \n  域名到真实IP的寻址过程\n- 发起TCP连接\n  \n  三次握手🤝，确定 **client** ，**server** 双端的接受发送能力\n- 发起Http请求\n- 服务器处理请求并返回HTTP报文\n- 浏览器解析渲染页面\n\n## 3. 说一下 Http 缓存策略，有什么区别，分别解决了什么问题\n   \n   浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。\n\n  - 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。\n  - 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified通过请求 发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\n\n  HTTP缓存都是从第二次请求开始的：\n\n  - 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；\n  - 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：\n  ![chrome-cache](chrome-cache.jpeg)\n\n## 4. 常见的Http状态码\n\n- 200 OK：表示从客户端发送给服务器的请求被正常处理并返回\n- 204 No Content：表示客户端发送给服务端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）\n- 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL\n- 302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL\n- 304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码\n- 400 Bad Request：表示请求报文中存在语法错误（一般指参数）\n- 401 Unauthorized：没有经过身份认证，需要通过HTTP认证\n- 403 Forbidden：身份认证过了，但是没有权限\n- 404 Not Found：(客户端问题)请求的资源没有找到，说明客户端错误的请求了不存在的资源\n- 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时\n- 503 Server Unavailable：服务不可用，一般指维护中或者服务重启中\n\n## 5. 跨域的复杂请求和简单请求的区别\n\n### 简单请求\n\n- HTTP方法是下列之一（HEAD、GET、POST）\n- HTTP头信息不超出以下几种字段\n  \n  **Accept**\n\n  **Accept-Language**\n\n  **Content-Type** （application/x-www-form-urlencoded、multipart/form-data、text/plain）\n\n任何一个 **不满足上述要求** 的请求，即被认为是复杂请求\n\n### 复杂请求\n\n- 一个复杂请求不仅有：包含通信内容的请求，同时也包含预请求。\n\n- 复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种\"预请求\"，此时作为服务端，也需要返回\"预回应\"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。\n"},"nextPost":{"slug":"css","frontmatter":{"title":"面试题集合（CSS篇）","date":"July 4, 2021","description":null},"excerpt":"","content":"\n1. css 伪类与伪元素区别\n   \n  1）伪类(pseudo-classes)\n\n    其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。\n    ⽐如:hover :active :visited :link :visited :first-child :focus :lang等\n    由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。\n    由此可以看出，它的功能和class有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。\n  \n  2）伪元素(Pseudo-elements)\n\n    DOM树没有定义的虚拟元素\n    核⼼就是需要创建通常不存在于⽂档中的元素，\n    ⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。\n    伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器\n    \n  2）伪类与伪元素的区别\n    \n    表示⽅法\n\n    CSS2 中伪类、伪元素都是以单冒号:表示,\n    CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示，\n    浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first�line, :first-letter 等)的单冒号写法。\n    CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。\n    CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头\n    定义不同\n\n    伪类即假的类，可以添加类来达到效果\n    伪元素即假元素，需要通过添加元素才能达到效果\n    \n    总结:\n\n    伪类和伪元素都是⽤来表示⽂档树以外的\"元素\"。\n    伪类和伪元素分别⽤单冒号:和双冒号::来表示。\n    伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，\n    是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类。\n  4）相同之处：\n\n    伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。\n  \n    不同之处：\n    \n    伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。\n    伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。"}},"__N_SSG":true}