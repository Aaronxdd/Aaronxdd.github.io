{"pageProps":{"frontmatter":{"title":"面试题集合（其他）","date":"July 11, 2021","description":null},"post":{"content":"\n## 1. 前端之SSO（单点登录）\n\n### 知识点\n- session存储用户信息于服务器\n- 通过session ID（cookie）来实现认证\n- 由于cookie不支持跨域，跨域时的解决方案不同于同域\n\n### 链接\n- [单点登录（SSO）看这一篇就够了](https://www.jianshu.com/p/75edcc05acfd)\n- [前端需要了解的 SSO 与 CAS 知识](https://juejin.cn/post/6844903509272297480)","excerpt":""},"previousPost":{"slug":"easy","frontmatter":{"title":"算法题（简单系列）","date":"July 6, 2021","description":null},"excerpt":"","content":"\n### 1. 两数之和\n\n#### 题目描述\n\n给定一个整数数组 **nums** 和一个目标值 **target**，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n#### 示例\n\n``` javascript\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n````\n\n#### 代码实现\n\n``` javascript\nconst findTotal = (nums, target) => {\n  for(let i = 0; i < nums.length; i++) {\n    if (nums.includes(target-nums[i])) {\n      return [i, nums.indexOf(target-nums[i])];\n    }\n  }\n}\n```\n\n\n### 2. 整数反转\n\n#### 题目描述\n\n![reverse-integer](reverse-integer.jpeg)\n\n\n#### 代码实现\n\n``` javascript\nconst reverse = (x) => {\n  let result = 0;\n  while (x !== 0) {\n    result = result * 10 + (x % 10);\n    x = Math.floor(x / 10);\n  }\n\n  if (result < -Math.pow(2, 31) || result > Math.pow(2, 31) - 1) {\n    return 0;\n  }\n  return result;\n};\n```\n\n### 3. 合并两个有序链表\n\n#### 题目描述\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n#### 示例1\n\n![merge-two-sorted-lists](merge-two-sorted-lists.jpeg)\n\n``` javascript\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n#### 示例2\n\n``` javascript\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n#### 示例3\n\n``` javascript\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n#### 提示\n\n- 两个链表的节点数目范围是 [0, 50]\n- -100 <= Node.val <= 100\n- l1 和 l2 均按 非递减顺序 排列\n\n``` javascript\n// 例如 现有两个链表\nconst ListNode1 = {\n  value: 0,\n  next: {\n    value: 2,\n    next: {\n      value: 4,\n      next: null\n    }\n  }\n}\n\nconst ListNode2 = {\n  value: 1,\n  next: {\n    value: 3,\n    next: {\n      value: 5,\n      next: null\n    }\n  }\n}\n```\n\n#### 实现\n\n``` javascript\nconst mergeTwoLists = (l1, l2) => {\n  if (l1 === null) {\n    return l2\n  }\n  if (l2 === null) {\n    return l1\n  }\n  if (l1.value < l2.value) {\n    l1.next = mergeTwoLists(l1.next, l2)\n    return l1\n  }\n  if (l2.value < l1.value) {\n    l2.next = mergeTwoLists(l2.next, l1)\n    return l2\n  }\n}\n```\n\n### 4. 最大子序和\n\n#### 题目描述\n\n给定一个整数数组 **nums** ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n#### 示例1\n\n``` javascript\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n```\n\n#### 示例2\n\n``` javascript\n输入：nums = [1]\n输出：1\n```\n\n#### 示例3\n\n``` javascript\n输入：nums = [0]\n输出：0\n```\n\n#### 示例4\n\n``` javascript\n输入：nums = [-1]\n输出：-1\n```\n\n#### 示例5\n\n``` javascript\n输入：nums = [-100000]\n输出：-100000\n```\n\n#### 提示\n- 1 <= nums.length <= 3 * 104\n- -105 <= nums[i] <= 105\n\n``` javascript\nconst maxSubArray = (nums) => {\n  let pre = 0;\n  let max = nums[0];\n  nums.forEach(x => {\n    pre = Math.max(pre + x, x);\n    max = Math.max(max, pre);\n  });\n  return max;\n};\n```\n\n### 5. 反转链表\n\n#### 题目描述\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n#### 示例:\n\n``` javascript\nconst ListNode = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: {\n          value: 5,\n          next: null\n        }\n      }\n    }\n  }\n}\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n```\n\n#### 限制：\n\n``` javascript\n0 <= 节点个数 <= 5000\n```\n\n``` javascript\nconst reverseList = (head) => {\n  let pre = null;\n  let cur = head;\n  while(cur) {\n    const next = cur.next;\n    cur.next = pre;\n    pre = cur;\n    cur = next;\n  }\n  return pre;\n}\n```\n\n"},"nextPost":null},"__N_SSG":true}